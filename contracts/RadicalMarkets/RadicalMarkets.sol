// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";

import "../interfaces/IDC.sol";
import "./BokkyPooBahsDateTimeContract.sol";

contract RadicalMarkets is ERC721Upgradeable, OwnableUpgradeable, PausableUpgradeable {
    struct RentalInfo {
        address prevRenter;
        address nextRenter;
        uint256 price;
    }

    /// @dev Grace period for renewing a domain
    uint256 public constant GRACE_PERIOD = 90 days;

    /// @dev DC contract address
    IDC public dc;

    /// @dev BokkyPooBahsDateTimeContract address
    BokkyPooBahsDateTimeContract public dateTimeController;

    /// @dev RadicalMarkets TokenId -> Year -> Month -> RentalInfo
    mapping(bytes32 => mapping(uint256 => mapping(uint256 => RentalInfo))) public rentals;

    /// @dev Revenue account
    address public revenueAccount;

    // modifier onlyDCOwner(string memory _name) {
    //     address dcOwner = IDC(dc).ownerOf(_name);
    //     require(msg.sender == dcOwner, "RadicalMarkets: only DC owner");
    //     _;
    // }

    event RevenueAccountChanged(address indexed from, address indexed to);

    modifier whenDomainNotExistOrExpired(string memory _name) {
        uint256 domainExpireAt = dc.nameExpires(_name);
        require(domainExpireAt == 0 || domainExpireAt < block.timestamp, "RadicalMarkets: domain exists or in use");
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address _dc, address _revenueAccount) external initializer {
        __ERC721_init(".country Domains Radical Markets", "DCRadicalMarkets");
        __Pausable_init();
        __Ownable_init();

        require(_dc != address(0), "RadicalMarkets: zero address");
        require(_revenueAccount != address(0), "RadicalMarkets: zero address");

        dc = IDC(_dc);
        revenueAccount = _revenueAccount;
    }

    /// @notice Set the DC contract address
    /// @param _dc DC contract address
    function setDCAddress(address _dc) external onlyOwner {
        require(_dc != address(0), "RadicalMarkets: zero address");

        dc = IDC(_dc);
    }

    /// @notice Set the revenue account
    /// @param _revenueAccount revenue account address
    function setRevenueAccount(address _revenueAccount) public onlyOwner {
        require(_revenueAccount != address(0), "RadicalMarkets: zero address");

        emit RevenueAccountChanged(revenueAccount, _revenueAccount);

        revenueAccount = _revenueAccount;
    }

    // To create a new domain, the client needs to first call commit on DC contract,
    // using a commitment generated by makeCommitment or equivalent computation at the client side.
    // The secret can be any value. The client then needs to call register using the same parameters used in makeCommitment.
    function rentDomain(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) external payable whenNotPaused {
        uint256 domainExpireAt = dc.nameExpires(_name);
        bool isDomainNotExist = domainExpireAt == 0;
        bool isDomainInUse = domainExpireAt != 0 && block.timestamp <= domainExpireAt;
        bool isDomainInGracePeriod = domainExpireAt < block.timestamp &&
            block.timestamp <= domainExpireAt + GRACE_PERIOD;

        uint256 currentYear = dateTimeController.getYear(block.timestamp);
        uint256 currentMonth = dateTimeController.getMonth(block.timestamp);
        uint256 startTimestampToRent = dateTimeController.timestampFromDate(_year, _month, 1);
        uint256 endTimestampToRent = dateTimeController.addMonths(startTimestampToRent, _durationInMonth);

        // the rental start date can't be in the past
        require(
            ((currentYear == _year && currentMonth <= _month) || currentYear < _year),
            "RadicalMarkets: start date in the past"
        );

        if (isDomainNotExist) {
            // if the domain doesn't exist, rent it from the current month
            require(_year == currentYear && _month == currentMonth, "RadicalMarkets: !isDomainNotExist");
            _rentDomainNotExist(_name, _year, _month, _durationInMonth, _secret);
        } else if (isDomainInUse) {
            // if the domain is in use, rent it from the next month
            require(
                (currentYear == _year && currentMonth < _month) || (currentYear < _year),
                "RadicalMarkets: !isDomainInUse"
            );
            _rentDomainInUse(_name, _year, _month, _durationInMonth, _secret);
        } else if (isDomainInGracePeriod) {
            // if the domain is in grace period, rent it from the current month
            require(_year == currentYear && _month == currentMonth, "RadicalMarkets: !isDomainInGracePeriod");
            _rentDomainInGracePeriod(_name, _year, _month, _durationInMonth, _secret);
        } else {
            // if domain is expired fully, rent it from the current month
            require(_year == currentYear && _month == currentMonth, "RadicalMarkets: !isDomainExpiredFully");
            _rentDomainExpiredFully(_name, _year, _month, _durationInMonth, _secret);
        }
    }

    function _rentDomainNotExist(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) internal {
        // mint the `RadicalMarkets` NFT
        bytes32 tokenId = keccak256(bytes(_name));
        _mint(msg.sender, uint256(tokenId));

        // store the rental info
        for (uint256 i; i < _durationInMonth; ) {
            uint256 yearToSet = _year + (_month + i) / 12;
            uint256 monthToSet = (_month + i) % 12;
            uint256 domainRentalPrice = getDomainRentalPrice(_name, _year, _month);

            // handle the payment (half to the revenue account, half to the previous renter)
            // since the previous renter doesn't exist, the revenue account gets the full amount
            require(msg.value == domainRentalPrice, "RadicalMarkets: invalid rental price");
            revenueAccount.call{value: domainRentalPrice}("");

            RentalInfo memory rental = RentalInfo({
                prevRenter: address(0),
                nextRenter: msg.sender,
                price: domainRentalPrice * 2
            });
            rentals[tokenId][yearToSet][monthToSet] = rental;

            unchecked {
                ++i;
            }
        }

        // register the domain and lock it
        bytes32 commitment = dc.makeCommitment(_name, address(this), _secret);
        dc.commit(commitment);
        dc.register(_name, address(this), _secret);
    }

    function _rentDomainInUse(string memory _name, uint256 _year, uint256 _month, uint256 _durationIm) internal {}

    function _rentDomainInGracePeriod(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationIm
    ) internal {}

    function _rentDomainExpiredFully(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationIm
    ) internal {}

    function getDomainRentalPrice(
        string memory _name,
        uint256 _year,
        uint256 _month
    ) public view returns (uint256 price) {
        (, , price) = getRentalInfo(_name, _year, _month);
        if (price == 0) price = 1 ether; // base rental price is 1 ONE
    }

    function getRentalInfo(
        string memory _name,
        uint256 _year,
        uint256 _month
    ) public view returns (address prevRenter, address nextRenter, uint256 price) {
        bytes32 tokenId = keccak256(bytes(_name));
        RentalInfo memory rental = rentals[tokenId][_year][_month];
        prevRenter = rental.prevRenter;
        nextRenter = rental.nextRenter;
        price = rental.price;
    }

    /// @notice Withdraw funds
    /// @dev Only owner of the revenue account can withdraw funds
    function withdraw() external {
        require(
            msg.sender == owner() || msg.sender == revenueAccount,
            "RadicalMarkets: must be owner or revenue account"
        );
        (bool success, ) = revenueAccount.call{value: address(this).balance}("");
        require(success, "RadicalMarkets: failed to withdraw");
    }

    /// @notice Pause the contract
    function pause() external onlyOwner {
        _pause();
    }

    /// @notice Unpause the contract
    function unpause() external onlyOwner {
        _unpause();
    }
}
