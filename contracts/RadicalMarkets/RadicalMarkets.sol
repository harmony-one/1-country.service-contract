// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";

import "../interfaces/IDC.sol";
import "./BokkyPooBahsDateTimeContract.sol";

contract RadicalMarkets is ERC721Upgradeable, OwnableUpgradeable, PausableUpgradeable {
    struct RentalInfo {
        address owner;
        address renter;
        uint256 rentalStartAt;
        uint256 duration; // months
    }

    /// @dev Grace period for renewing a domain
    uint256 public constant GRACE_PERIOD = 90 days;

    /// @dev DC contract address
    IDC public dc;

    /// @dev BokkyPooBahsDateTimeContract address
    BokkyPooBahsDateTimeContract public dateTimeController;

    /// @dev RadicalMarkets TokenId -> RentalInfo
    mapping(bytes32 => RentalInfo) public rentals;

    /// @dev RadicalMarkets TokenId -> Year -> Month -> Price
    mapping(bytes32 => mapping(uint256 => mapping(uint256 => uint256))) public rentalPrices;

    /// @dev Revenue account
    address public revenueAccount;

    // modifier onlyDCOwner(string memory _name) {
    //     address dcOwner = IDC(dc).ownerOf(_name);
    //     require(msg.sender == dcOwner, "RadicalMarkets: only DC owner");
    //     _;
    // }

    event RevenueAccountChanged(address indexed from, address indexed to);

    modifier whenDomainNotExistOrExpired(string memory _name) {
        uint256 domainExpireAt = dc.nameExpires(_name);
        require(domainExpireAt == 0 || domainExpireAt < block.timestamp, "RadicalMarkets: domain exists or in use");
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address _dc, address _revenueAccount) external initializer {
        __ERC721_init(".country Domains Radical Markets", "DCRadicalMarkets");
        __Pausable_init();
        __Ownable_init();

        require(_dc != address(0), "RadicalMarkets: zero address");
        require(_revenueAccount != address(0), "RadicalMarkets: zero address");

        dc = IDC(_dc);
        revenueAccount = _revenueAccount;
    }

    /// @notice Set the DC contract address
    /// @param _dc DC contract address
    function setDCAddress(address _dc) external onlyOwner {
        require(_dc != address(0), "RadicalMarkets: zero address");

        dc = IDC(_dc);
    }

    /// @notice Set the revenue account
    /// @param _revenueAccount revenue account address
    function setRevenueAccount(address _revenueAccount) public onlyOwner {
        require(_revenueAccount != address(0), "RadicalMarkets: zero address");

        emit RevenueAccountChanged(revenueAccount, _revenueAccount);

        revenueAccount = _revenueAccount;
    }

    // To create a new domain, the client needs to first call commit on DC contract,
    // using a commitment generated by makeCommitment or equivalent computation at the client side.
    // The secret can be any value. The client then needs to call register using the same parameters used in makeCommitment.
    function rentDomain(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) external payable whenDomainNotExistOrExpired(_name) {
        // // register the domain
        // bytes32 commitment = dc.makeCommitment(_name, address(this), _secret);
        // dc.commit(commitment);
        // dc.register(_name, address(this), _secret);

        uint256 domainExpireAt = dc.nameExpires(_name);
        bool isDomainNotExist = domainExpireAt == 0;
        bool isDomainInUse = domainExpireAt != 0 && block.timestamp <= domainExpireAt;
        bool isDomainInGracePeriod = domainExpireAt < block.timestamp &&
            block.timestamp <= domainExpireAt + GRACE_PERIOD;
        // require(domainExpireAt == 0 || block.timestamp <= domainExpireAt, "RadicalMarkets: domain in use"); // whenDomainNotExistOrExpired
        // require(
        //     (currentYear < _year) || (currentYear == _year && currentMonth <= _month),
        //     "RadicalMarkets: invalid start date"
        // );
        // require(block.timestamp <= startTimestampToRent, "RadicalMarkets: invalid start date");
        // require(endTimestampToRent <= domainExpireAt, "RadicalMarkets: invalid rental duration");

        uint256 currentYear = dateTimeController.getYear(block.timestamp);
        uint256 currentMonth = dateTimeController.getMonth(block.timestamp);
        uint256 startTimestampToRent = dateTimeController.timestampFromDate(_year, _month, 1, 0, 0, 0);
        uint256 endTimestampToRent = dateTimeController.addMonths(startTimestampToRent, _durationInMonth);

        // the rental start date can't be in the past
        require(
            ((currentYear == _year && currentMonth <= _month) || currentYear < _year),
            "RadicalMarkets: start date in the past"
        );

        if (isDomainNotExist) {
            // if the domain doesn't exist, rent it from the current month
            require(_year == currentYear && _month == currentMonth, "RadicalMarkets: invalid start date");
            _rentDomainNotExist(_name, _year, _month, _durationInMonth, _secret);
        } else if (isDomainInUse) {} else if (isDomainInGracePeriod) {} else {
            // domain expired fully
        }

        // mint the `RadicalMarkets` NFT
        uint256 tokenId = uint256(keccak256(_name));
        // if (_exists(tokenId)) _burn(tokenId);
        uint256 domainExpireAt = dc.nameExpires(_name);
        if (block.timestamp <= domainExpireAt) {
            // domain exist
        } else {
            // domain not exist or expired
            uint256 tokenId = uint256(keccak256(_name));
            if (_exists(tokenId)) {
                _burn(tokenId);
            }
        }
        RentalInfo memory rental = rentals[tokenId];
        require(
            !_exists(tokenId) || (rental.rentalStartAt + duration < block.timestamp),
            "RadicalMarkets: already in use"
        );
        if (_exist(tokenId) && (block.timestamp <= rentalStartAt + duration)) {}
        _burn(tokenId);
        delete _mint(msg.sender, tokenId);

        // store the rental info
        RentalInfo storage rental = rentals[tokenId];
    }

    function _rentDomainNotExist(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) internal {
        // mint the `RadicalMarkets` NFT
        bytes32 tokenId = keccak256(bytes(_name));
        _mint(msg.sender, tokenId);

        // store the rental info
        rentals[tokenId].owner = msg.sender;
        rentals[tokenId].renter = msg.sender;
        rentals[tokenId].rentalStartAt = block.timestamp;
        rentals[tokenId].duation = _durationInMonth;

        // check the rental price
        uint256 domainRentalPrice = getDomainRentalPrice(_name, _year, _month);
        require(msg.value == domainRentalPrice, "RadicalMarkets: invalid rental price");

        // set the next domain rental price
        for (uint256 i; i < _durationInMonth; ) {
            uint256 yearToSet = _year + (_month + i) / 12;
            uint256 monthToSet = (_month + i) % 12;
            rentalPrices[tokenId][yearToSet][monthToSet] = domainRentalPrice * 2;

            unchecked {
                ++i;
            }
        }

        // register the domain and lock it
        bytes32 commitment = dc.makeCommitment(_name, address(this), _secret);
        dc.commit(commitment);
        dc.register(_name, address(this), _secret);
    }

    function _rentDomainInUse(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationIm
    ) internal {
        
    }

    function getDomainRentalPrice(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth
    ) public view returns (uint256 price) {
        bytes32 tokenId = keccak256(bytes(_name));
        price = rentalPrices[tokenId][_year][_month];
        if (price == 0) price = 1 ether; // base rental price is 1 ONE
    }

    /// @notice Withdraw funds
    /// @dev Only owner of the revenue account can withdraw funds
    function withdraw() external {
        require(
            msg.sender == owner() || msg.sender == revenueAccount,
            "RadicalMarkets: must be owner or revenue account"
        );
        (bool success, ) = revenueAccount.call{value: address(this).balance}("");
        require(success, "RadicalMarkets: failed to withdraw");
    }

    /// @notice Pause the contract
    function pause() external onlyOwner {
        _pause();
    }

    /// @notice Unpause the contract
    function unpause() external onlyOwner {
        _unpause();
    }
}
