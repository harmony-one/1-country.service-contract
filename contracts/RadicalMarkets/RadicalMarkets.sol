// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol";

import "../interfaces/IDC.sol";
import "./BokkyPooBahsDateTimeContract.sol";

contract RadicalMarkets is ERC721Upgradeable, OwnableUpgradeable, PausableUpgradeable {
    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.AddressToUintMap;

    struct RentalInfo {
        address prevRenter;
        address nextRenter;
        uint256 price;
    }

    /// @dev Grace period for renewing a domain
    uint256 public constant GRACE_PERIOD = 90 days;

    /// @dev DC contract address
    IDC public dc;

    /// @dev BokkyPooBahsDateTimeContract address
    BokkyPooBahsDateTimeContract public dateTimeController;

    /// @dev RadicalMarkets TokenId -> Year -> Month -> RentalInfo
    mapping(bytes32 => mapping(uint256 => mapping(uint256 => RentalInfo))) public rentals;

    /// @dev Revenue account
    address public revenueAccount;

    /// @dev payment buffer (Receiver -> Amount)
    EnumerableMapUpgradeable.AddressToUintMap internal _receiverBuffer;

    // modifier onlyDCOwner(string memory _name) {
    //     address dcOwner = IDC(dc).ownerOf(_name);
    //     require(msg.sender == dcOwner, "RadicalMarkets: only DC owner");
    //     _;
    // }

    event RevenueAccountChanged(address indexed from, address indexed to);

    modifier whenDomainNotExistOrExpired(string memory _name) {
        uint256 domainExpireAt = dc.nameExpires(_name);
        require(domainExpireAt == 0 || domainExpireAt < block.timestamp, "RadicalMarkets: domain exists or in use");
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address _dc, address _revenueAccount) external initializer {
        __ERC721_init(".country Domains Radical Markets", "DCRadicalMarkets");
        __Pausable_init();
        __Ownable_init();

        require(_dc != address(0), "RadicalMarkets: zero address");
        require(_revenueAccount != address(0), "RadicalMarkets: zero address");

        dc = IDC(_dc);
        revenueAccount = _revenueAccount;
    }

    /// @notice Set the DC contract address
    /// @param _dc DC contract address
    function setDCAddress(address _dc) external onlyOwner {
        require(_dc != address(0), "RadicalMarkets: zero address");

        dc = IDC(_dc);
    }

    /// @notice Set the revenue account
    /// @param _revenueAccount revenue account address
    function setRevenueAccount(address _revenueAccount) public onlyOwner {
        require(_revenueAccount != address(0), "RadicalMarkets: zero address");

        emit RevenueAccountChanged(revenueAccount, _revenueAccount);

        revenueAccount = _revenueAccount;
    }

    // To create a new domain, the client needs to first call commit on DC contract,
    // using a commitment generated by makeCommitment or equivalent computation at the client side.
    // The secret can be any value. The client then needs to call register using the same parameters used in makeCommitment.
    function rentDomain(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) external payable whenNotPaused {
        uint256 domainExpireAt = dc.nameExpires(_name);
        bool isDomainNotExist = domainExpireAt == 0;
        bool isDomainInUse = domainExpireAt != 0 && block.timestamp <= domainExpireAt;
        bool isDomainInGracePeriod = domainExpireAt < block.timestamp &&
            block.timestamp <= domainExpireAt + GRACE_PERIOD;

        uint256 currentYear = dateTimeController.getYear(block.timestamp);
        uint256 currentMonth = dateTimeController.getMonth(block.timestamp);
        uint256 startTimestampToRent = dateTimeController.timestampFromDate(_year, _month, 1);
        // uint256 endTimestampToRent = dateTimeController.addMonths(startTimestampToRent, _durationInMonth);

        // the rental start date can't be in the past
        require(
            ((currentYear == _year && currentMonth <= _month) || currentYear < _year),
            "RadicalMarkets: start date in the past"
        );

        if (isDomainNotExist) {
            // if the domain doesn't exist, rent it from the current month
            require(_year == currentYear && _month == currentMonth, "RadicalMarkets: !isDomainNotExist");
            _rentDomainNotExist(_name, _year, _month, _durationInMonth, _secret);
        } else if (isDomainInUse) {
            // if the domain is in use, rent it from the next month
            require(
                (currentYear == _year && currentMonth < _month) || (currentYear < _year),
                "RadicalMarkets: !isDomainInUse"
            );
            _rentDomainInUse(_name, _year, _month, _durationInMonth, _secret);
        } else if (isDomainInGracePeriod) {
            // if the domain is in grace period, rent it from the current month
            require(_year == currentYear && _month == currentMonth, "RadicalMarkets: !isDomainInGracePeriod");
            _rentDomainInGracePeriod(_name, _year, _month, _durationInMonth, _secret);
        } else {
            // if domain is expired fully, rent it from the current month
            require(_year == currentYear && _month == currentMonth, "RadicalMarkets: !isDomainExpiredFully");
            _rentDomainExpiredFully(_name, _year, _month, _durationInMonth, _secret);
        }
    }

    function _rentDomainNotExist(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) internal {
        // mint the `RadicalMarkets` NFT
        bytes32 tokenId = keccak256(bytes(_name));
        _mint(msg.sender, uint256(tokenId));

        // handle the rental
        _handleRental(_name, _year, _month, _durationInMonth, msg.value);

        // register the domain and lock it
        bytes32 commitment = dc.makeCommitment(_name, address(this), _secret);
        dc.commit(commitment);
        dc.register(_name, address(this), _secret);
    }

    function _rentDomainInUse(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) internal {
        // handle the rental
        _handleRental(_name, _year, _month, _durationInMonth, msg.value);
    }

    function _rentDomainInGracePeriod(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) internal {}

    function _rentDomainExpiredFully(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        bytes32 _secret
    ) internal {}

    function _handleRental(
        string memory _name,
        uint256 _year,
        uint256 _month,
        uint256 _durationInMonth,
        uint256 _paymentAmount
    ) internal {
        bytes32 tokenId = keccak256(bytes(_name));

        uint256 startTimestampToRent = dateTimeController.timestampFromDate(_year, _month, 1);
        uint256 rentalPayment = _paymentAmount;

        // store the rental info
        for (uint256 i = 1; i <= _durationInMonth; ) {
            uint256 timestampToRent = dateTimeController.addMonths(startTimestampToRent, i);

            uint256 yearToSet = dateTimeController.getYear(timestampToRent);
            uint256 monthToSet = dateTimeController.getMonth(timestampToRent);
            uint256 domainRentalPrice = getDomainRentalPrice(_name, _year, _month);

            require(rentalPayment >= domainRentalPrice, "RadicalMarkets: not enough payment");
            rentalPayment -= domainRentalPrice;

            // store the payment amount to the `_receiverBuffer` to avoid the multiple payment txs
            // half to the revenue account, half to the previous renter
            // if the previous renter doesn't exist, the revenue account gets the full amount
            address prevRenter = rentals[tokenId][yearToSet][monthToSet].prevRenter;
            uint256 amount;
            if (prevRenter != address(0)) {
                (, amount) = _receiverBuffer.tryGet(prevRenter);
                _receiverBuffer.set(prevRenter, amount + domainRentalPrice / 2);
                (, amount) = _receiverBuffer.tryGet(revenueAccount);
                _receiverBuffer.set(revenueAccount, amount + domainRentalPrice / 2);
            } else {
                (, amount) = _receiverBuffer.tryGet(revenueAccount);
                _receiverBuffer.set(revenueAccount, amount + domainRentalPrice);
            }

            RentalInfo memory rental = RentalInfo({
                prevRenter: prevRenter,
                nextRenter: msg.sender,
                price: domainRentalPrice
            });
            rentals[tokenId][yearToSet][monthToSet] = rental;

            unchecked {
                ++i;
            }
        }

        // transfer the payment
        for (uint256 i; i < _receiverBuffer.length(); ) {
            (address receiver, uint256 amount) = _receiverBuffer.at(i);
            receiver.call{value: amount}("");
            _receiverBuffer.remove(receiver);

            unchecked {
                ++i;
            }
        }
    }

    function getDomainRentalPrice(
        string memory _name,
        uint256 _year,
        uint256 _month
    ) public view returns (uint256 price) {
        (, , price) = getRentalInfo(_name, _year, _month);
        price *= 2; // double the price every month

        if (price == 0) price = 1 ether; // base rental price is 1 ONE
    }

    function getRentalInfo(
        string memory _name,
        uint256 _year,
        uint256 _month
    ) public view returns (address prevRenter, address nextRenter, uint256 price) {
        bytes32 tokenId = keccak256(bytes(_name));
        RentalInfo memory rental = rentals[tokenId][_year][_month];
        prevRenter = rental.prevRenter;
        nextRenter = rental.nextRenter;
        price = rental.price;
    }

    /// @notice Withdraw funds
    /// @dev Only owner of the revenue account can withdraw funds
    function withdraw() external {
        require(
            msg.sender == owner() || msg.sender == revenueAccount,
            "RadicalMarkets: must be owner or revenue account"
        );
        (bool success, ) = revenueAccount.call{value: address(this).balance}("");
        require(success, "RadicalMarkets: failed to withdraw");
    }

    /// @notice Pause the contract
    function pause() external onlyOwner {
        _pause();
    }

    /// @notice Unpause the contract
    function unpause() external onlyOwner {
        _unpause();
    }
}
